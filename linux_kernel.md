
- _POSIX_ - Portable Operating System Interface
- _API_ - Application Programming Interface
- _VM_ - Virtual Memory
- _US_ - user space
- _KS_ - kernel space
- _IP_ - instruction pointer
- _CPU_ - central processing unit
- _DMA_ - direct memory access
- _dev_ - устройство
- _NUMA_ - Non-Uniform Memory Access
- _MMU_ - memory management unit
- _SMP_ - Symmetric Multiprocessing
- _IPI_ - inter processors interrupt
- _APIC_ - Advanced Programmable Interrupt Controller
- _LAPIC_ - local APIC
- _IOAPIC_ - input/output APIC
- *V*T-x - Аппаратная виртуализация
- _ОС_ - операционная система
- _ASM_ - assembly language
- _BIO_ - block input/output
- _IPC_ - inter-process communication
- _TCP/IP_ - Transmission Control Protocol / Internet Protocol
- _ICMP_- Internet Control Message Protocol
 
всё касается x86

---
##### Основа

ядро ОС:

1. API к аппаратуре  
   - Linux _API_ соответствует большей части _POSIX_, но не полностью
   - системный вызов
     - отличается от обычного вызова
       - передача управления из _US_ в _KS_
       - с переключением привелегий - в привелигированный режим (от 3 к 0)
   - с точки зрения _ASM_
       - раньше - программное прерывание (инструкция int)
       - сейчас - инструкция sysenter
    - является интерфейсом к ядру    
2. Управление ресурсами:
   - делить доступ между процессами
   - ресурсы
     - _CPU_
     - Memory
     - Периферия (жёсткие диски, мыши, клавы, моники и пр.)

I. Ядро, 2.5 типа
   - **монолитное**
     - подсистемы
       - отдельные части одной большой программы
       - в одном адресном простанстве
       - вызывают функции других подсистем
         * **модульное**
           - подсистемы можно подключать/отключать на лету
           - это Linux (можно собрать с разными модулями)
       - ++ легче разрабатывать (всё в одном месте)
       - ++ быстрее работает
   - **микро**
     - ядро - подсистема взаимодействия подсистем
     - подсистема управления памятью (для ускорения)
     -   ++ безопаснее (можно восстановить подсисетему)
     -   ++ легче разрабатывать (декомпозировано, легче отладить так как мало)

II. Разбор печати "Hello World"
 - **printf()** - функция библиотеки (*написал разрботчик*)
   - **write()** - функцию (*его вызывает **printf()***) - не системный вызов
     - в библиотеке glibc есть имена дублирующие имена системных вызовов, но ими не являются
     - отличается от системного вызова, ожидаем что glibc кто-то пристегнёт (но может не быть)
     - отличается от системного вызова - может переставить аргументы, ядро может использовать свои внутренние структуры (таймеры - свои идентификаторы)
       - **sys_write()** - системный вызов (*его вызывает **write()***)

III. Дополнение к _API_ между ядром и _US_ кроме системных вызовов
 - procfs
   - псевдо файловая, для отображения информации о выполняющихся в ядре процессах (нет системного вызова для получения этой информации)
 - sysctl
   - оформлена как файловая система
   - для конфигурирования констант ядра (куча их в TCP/IP стеке) из US
 - netlink
   - хитрый тип сокета, получателем данных является ядро, после обработки отвечает
   - 99.9 на нём написано API к Network подсистеме

IV. Рекомендации к изучению
- https://kernelnewbies.org/ - как точка входа для начинающих
- исходники ядра

Что можно ещё изучить, возможные лекции:
- Как ядро выглядить с точки зрения программиста
- Что происходит на загрузке
- Контекст исполнения кода
- Синхронизация. MM: управление памятью в ядре, управление памятью программ
- Планировщик. Управление процессами
    
- Файловые системы (VFS)
- Сетевой код
- Особенности работы с дисками
- Бонус: kernel developers community

---
##### Отступления

1*.
- в VM адреса среди [0:2^разрядность)
  - в VM разделены
    - US
      - IP бегает только в US
    - KS начиная с адреса вверх
      - IP бегает только в KS

1**.
- выполнение кода в VM (вызов функции)
  - передача управления (jmp, call) из US в KS
  - меняются регистры процессора (IP, ...)
    - call меняет значения регистров процессора
    - jmp - в регистрах указывается куда вернуться после RETURN

2*.
В аппаратуры для ядра должны быть (мин. требования для работы ядра Linux):
- защищённый режим - разделение привилегий кода
- страничная адресация - режим
- таймер/прерывания - генерация в предсказуемой манере
* ещё в ядре бывает:
  - DMA
        - данные ядро пишет в память; говорит dev-у записать к себе; dev фоново читает; dev по завершение присылает прерывание
        - до этого от CPU к dev через порты по 8 байт (инструкции in, out)

  - NUMA
    - на многопроцессорной системе CPU ходят к физ. памяти через несколько MMU, которые поровну делят память. MMU общаются между собой
    - ++ для ускорения работы программа где много памяти
    - ++ доступ CPU к своей памяти быстрее (памяти меньше) через MMU_1, к чужой (MMU_1 - MMU - 2)- медленнее
    - -- ядру нужно разбаласировать процессы с учётом NUMA-зон (пришить процесс к CPU)
    - -- ядру нужно согласовывать выделение объектов в NUMA-зоне и использовать только с принадлежащих CPU

  - SMP - одинаковые CPU
    - IPI - прерывание не только от dev но и соседнего CPU (например. планировщик CPU_1 вытесняет процесс (шлёт IPI) на соседнем CPU_2 съевший много CPU_2-time)

  - APIC - CPU получает прерывания не от железа, а от APIC. APIC получает прерывания от железа
    - LAPIC - пришит к одному CPU
    - IOAPIC - принимает от железа прерывания, передаёт LAPIC

  - VT-x - запуск виртуальных машин эффиктивно на CPU

2**
Уровни привелегий:

 - 0 
   - самый высокий
   - только здесь настройка страничной адресации (2*)
   - здесь ядро
 - 1,2
   - раньше до VT-x для выполнения кода гостевой ОС (чуть больше полномочий кода)
 - 3 
   - самый низкий
   - нельзя запрещать прерывания
   - ...
   - здесь US

    нельзя ни на каком обратится к физической памяти

I*. Подсистемы ядра:
- File sysem
- Memory managment
- Network
- BIO- огромная
  - блочное dev
    - ввод вывод блоками производится фиксированного размера в произвольное место у
    - доступ к dev должен производится по произвольному адресу
- (подсистема управление подсистемами - не Linux)
- Управление процессами
- _IPC_

---

У сетевой карты - доступ не произвольный

Прерывание - вызывается если dev что-то говорит _CPU_

В Linux нет _ICMP_ сокетов, используются сырые сокеты (SOCK_RAW)
